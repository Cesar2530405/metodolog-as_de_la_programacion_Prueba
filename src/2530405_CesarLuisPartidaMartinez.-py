# Portada:
# Nombre: Cesar Luis Partida Martinez
# Matrícula: 2530405
# Grupo: IM 1-2


# Resumen ejecutivo:

# Este archivo contiene seis ejercicios enfocados en el uso de bucles
# en Python (for y while). Explica y muestra ejemplos de:
# - for con range() para iteraciones contadas,
# - for recorriendo listas,
# - while con sentinela para lectura repetida,
# - while para control de intentos (password) y menús repetitivos,
# - bucles anidados para imprimir patrones.
# Se incluyen validaciones, tres casos de prueba por problema (normal,
# borde y error), y conclusiones. Los comentarios están en español y el
# código y los mensajes impresos están en inglés según la consigna.

# Principios y buenas prácticas 

# - Use for when you know the number of iterations (e.g., range).
# - Use while when iterations depend on a condition (e.g., sentinel).
# - Initialize counters and accumulators before loops.
# - Update while loop control variables inside the loop to avoid infinite loops.
# - Keep loop bodies simple; extract complex logic into functions.
# - Validate inputs before entering loops when possible.

# CONSTANTS (use UPPER_SNAKE_CASE)

PASS_THRESHOLD = 70.0
MAX_ATTEMPTS = 3
SENTINEL_VALUE = -1  



# Template header to place before each problem (comments in Spanish)
# (Will be repeated before each problem implementation)

# Problem X: <short title>
# Description: 2–4 líneas explicando qué hace el programa.
#
# Inputs:
# - ...
#
# Outputs:
# - ...
#
# Validations:
# - ...
#
# Test cases:
# 1) Normal: ...
# 2) Border: ...
# 3) Error: ...




# Problem 1: Sum of range with for
# Description: Calculate sum of integers 1..n and sum of even numbers in the same range using for.
#
# Inputs:
# - n (int)
#
# Outputs:
# - "Sum 1..n:" <total_sum>
# - "Even sum 1..n:" <even_sum>
#
# Validations:
# - n convertible to int and n >= 1 else print "Error: invalid input"
#
# Test cases:
# 1) Normal: n=10 -> total_sum=55, even_sum=30
# 2) Border: n=1 -> total_sum=1, even_sum=0
# 3) Error: n=0 or n="a" -> "Error: invalid input"

def problem1_sum_range(n):
    """
    Returns a dict with total_sum and even_sum or None on error. Prints outputs in English.
    """
    try:
        n_int = int(n)
    except (TypeError, ValueError):
        print("Error: invalid input")
        return None

    if n_int < 1:
        print("Error: invalid input")
        return None

    total_sum = 0
    even_sum = 0
    # for with range
    for i in range(1, n_int + 1):
        total_sum += i
        if i % 2 == 0:
            even_sum += i

    print("Sum 1..n:", total_sum)
    print("Even sum 1..n:", even_sum)
    return {"total_sum": total_sum, "even_sum": even_sum}



# Problem 2: Multiplication table with for
# Description: Generate multiplication table of base from 1..m.
#
# Inputs:
# - base (int)
# - m (int)
#
# Outputs:
# - Lines like "5 x 1 = 5"
#
# Validations:
# - base and m convertible to int and m >= 1 else "Error: invalid input"
#
# Test cases:
# 1) Normal: base=5, m=4 -> 4 lines
# 2) Border: m=1 -> single line
# 3) Error: m=0 or base non-int -> "Error: invalid input"

def problem2_multiplication_table(base, m):
    """
    Prints the multiplication table lines and returns a list of strings (lines) or None on error.
    """
    try:
        base_int = int(base)
        m_int = int(m)
    except (TypeError, ValueError):
        print("Error: invalid input")
        return None

    if m_int < 1:
        print("Error: invalid input")
        return None

    lines = []
    for i in range(1, m_int + 1):
        product = base_int * i
        line = f"{base_int} x {i} = {product}"
        print(line)
        lines.append(line)
    return lines



# Problem 3: Average of numbers with while and sentinel
# Description: Read numbers until sentinel (-1) is seen; compute count and average.
#
# Inputs:
# - numbers_iterable (an iterable of values that simulate repeated inputs)
# - sentinel_value (int/float) default SENTINEL_VALUE
#
# Outputs:
# - "Count:" <count>
# - "Average:" <average>
# - If no valid data before sentinel: "Error: no data"
#
# Validations:
# - Each reading must be convertible to float; ignore conversions errors (print "Error: invalid input" and skip)
#
# Test cases:
# 1) Normal: [2,4,6,-1] -> Count:3 Average:4.0
# 2) Border: [-1] -> Error: no data
# 3) Error: ["a",5,-1] -> treat "a" as invalid input (skip), Count:1 Average:5.0

def problem3_average_with_sentinel(numbers_iterable, sentinel_value=SENTINEL_VALUE):
    """
    Simulates repeated readings using an iterable. Returns dict with count and average or None.
    Prints results/messages in English.
    """
    total = 0.0
    count = 0

    # We'll iterate over the provided iterable; when sentinel is found, stop.
    for raw in numbers_iterable:
        # Attempt convert to float
        try:
            val = float(raw)
        except (TypeError, ValueError):
            # According to instructions, attempt conversion and skip invalid inputs but print an error
            print("Error: invalid input")
            continue

        if val == sentinel_value:
            break

        total += val
        count += 1

    if count == 0:
        print("Error: no data")
        return None

    average = total / count
    # Print results
    print("Count:", count)
    print("Average:", round(average, 6))
    return {"count": count, "average": average}



# Problem 4: Password attempts with while
# Description: User has MAX_ATTEMPTS to enter correct password; success or locked.
#
# Inputs:
# - attempts_iterable (iterable of attempted passwords to simulate user input)
# - correct_password (string) default "admin123"
#
# Outputs:
# - If correct within attempts: "Login success"
# - If all attempts exhausted: "Account locked"
#
# Validations:
# - MAX_ATTEMPTS > 0
#
# Test cases:
# 1) Normal: attempts include correct within limit -> "Login success"
# 2) Border: correct on last attempt -> "Login success"
# 3) Error: no correct in attempts -> "Account locked"

def problem4_password_attempts(attempts_iterable, correct_password="admin123", max_attempts=MAX_ATTEMPTS):
    """
    Simulates reading password attempts from an iterable.
    Returns True for success, False for locked. Prints messages in English.
    """
    try:
        max_attempts_int = int(max_attempts)
    except (TypeError, ValueError):
        print("Error: invalid input")
        return None

    if max_attempts_int <= 0:
        print("Error: invalid input")
        return None

    attempts = 0
    for attempt in attempts_iterable:
        # If attempts already exhausted, break to avoid extra processing
        if attempts >= max_attempts_int:
            break

        # treat attempt as string
        entered = "" if attempt is None else str(attempt)
        attempts += 1

        if entered == correct_password:
            print("Login success")
            return True
        # else continue; loop will check attempts count

    # After loop, if success not returned
    if attempts >= max_attempts_int:
        print("Account locked")
        return False
    else:
        # If attempts_iterable ended before reaching attempts limit and no success:
        print("Account locked")
        return False



# Problem 5: Simple menu with while
# Description: Repeated text menu until option 0 is selected. Options: 1 greeting, 2 show counter, 3 increment, 0 exit.

# Inputs:
# - options_iterable (iterable of options chosen by user, e.g., ["1","3","2","0"])

# Outputs:
# - "Hello!" (option 1)
# - "Counter:" <counter_value> (option 2)
# - "Counter incremented" (option 3)
# - "Bye!" (option 0)
# - "Error: invalid option" for invalid options

# Validations:
# - Normalize option to int if possible; else invalid.
# - Accept only 0,1,2,3.

# Test cases:
# 1) Normal: ["1","3","2","0"]
# 2) Border: ["0"] immediate exit -> prints "Bye!"
# 3) Error: ["5","0"] -> prints error then "Bye!"

def problem5_simple_menu(options_iterable):
    """
    Simulates a menu controlled by an iterable of user choices.
    Returns final counter value. Prints messages in English.
    """
    counter = 0
    # We will iterate over provided options; stop when option 0 encountered.
    for raw_option in options_iterable:
        # Normalize option: try int conversion
        try:
            option = int(raw_option)
        except (TypeError, ValueError):
            print("Error: invalid option")
            continue

        if option == 0:
            print("Bye!")
            return counter
        elif option == 1:
            print("Hello!")
        elif option == 2:
            print("Counter:", counter)
        elif option == 3:
            counter += 1
            print("Counter incremented")
        else:
            print("Error: invalid option")
    # If iterable ended without 0, we decide to exit and say Bye!
    print("Bye!")
    return counter



# Problem 6: Pattern printing with nested loops
# Description: Print right triangle of asterisks with n rows. Optional inverted pattern implemented.

# Inputs:
# - n (int)
# - inverted (bool) optional to also print inverted pattern

# Outputs:
# - Lines with increasing asterisks
# - (Optional) inverted pattern after

# Validations:
# - n convertible to int and n >= 1 else "Error: invalid input"

# Test cases:
# 1) Normal: n=4 -> prints 4 lines "*".."****"
# 2) Border: n=1 -> prints "*"
# 3) Error: n=0 or non-int -> "Error: invalid input"

def problem6_pattern_printing(n, inverted=False):
    """
    Prints the pattern line by line and returns list of printed lines (including inverted if chosen).
    """
    try:
        n_int = int(n)
    except (TypeError, ValueError):
        print("Error: invalid input")
        return None

    if n_int < 1:
        print("Error: invalid input")
        return None

    printed_lines = []
    # Nested loop via multiplication string (preferred)
    for i in range(1, n_int + 1):
        line = "*" * i
        print(line)
        printed_lines.append(line)

    if inverted:
        # Optional inverted pattern
        for i in range(n_int, 0, -1):
            line = "*" * i
            print(line)
            printed_lines.append(line)

    return printed_lines


# Test driver: run 3 test cases per problem (normal, border, error)

def run_all_tests():
    print("\n" + "=" * 70)
    print("Problem 1 Tests (Sum of range with for)")
    print("-" * 70)
    # Normal
    print("\nTest 1 - Normal (n=10):")
    problem1_sum_range(10)
    # Border
    print("\nTest 2 - Border (n=1):")
    problem1_sum_range(1)
    # Error
    print("\nTest 3 - Error (n=0):")
    problem1_sum_range(0)

    print("\n" + "=" * 70)
    print("Problem 2 Tests (Multiplication table with for)")
    print("-" * 70)
    # Normal
    print("\nTest 1 - Normal (base=5,m=4):")
    problem2_multiplication_table(5, 4)
    # Border
    print("\nTest 2 - Border (m=1):")
    problem2_multiplication_table(7, 1)
    # Error
    print("\nTest 3 - Error (m=0):")
    problem2_multiplication_table(3, 0)

    print("\n" + "=" * 70)
    print("Problem 3 Tests (Average with sentinel)")
    print("-" * 70)
    # Normal
    print("\nTest 1 - Normal ([2,4,6,-1]):")
    problem3_average_with_sentinel([2, 4, 6, -1])
    # Border
    print("\nTest 2 - Border ([-1]):")
    problem3_average_with_sentinel([-1])
    # Error (includes invalid "a")
    print("\nTest 3 - Error ([\"a\",5,-1]):")
    problem3_average_with_sentinel(["a", 5, -1])

    print("\n" + "=" * 70)
    print("Problem 4 Tests (Password attempts with while)")
    print("-" * 70)
    # Normal: correct on first attempt
    print("\nTest 1 - Normal (['admin123']):")
    problem4_password_attempts(["admin123"])
    # Border: correct on last allowed attempt
    print("\nTest 2 - Border (['x','y','admin123'] with MAX_ATTEMPTS=3):")
    problem4_password_attempts(["x", "y", "admin123"])
    # Error: all wrong
    print("\nTest 3 - Error (['a','b','c']):")
    problem4_password_attempts(["a", "b", "c"])

    print("\n" + "=" * 70)
    print("Problem 5 Tests (Simple menu with while)")
    print("-" * 70)
    # Normal
    print("\nTest 1 - Normal (['1','3','2','0']):")
    problem5_simple_menu(["1", "3", "2", "0"])
    # Border: immediate exit
    print("\nTest 2 - Border (['0']):")
    problem5_simple_menu(["0"])
    # Error: invalid option then exit
    print("\nTest 3 - Error (['5','0']):")
    problem5_simple_menu(["5", "0"])

    print("\n" + "=" * 70)
    print("Problem 6 Tests (Pattern printing with nested loops)")
    print("-" * 70)
    # Normal
    print("\nTest 1 - Normal (n=4):")
    problem6_pattern_printing(4)
    # Border
    print("\nTest 2 - Border (n=1):")
    problem6_pattern_printing(1)
    # Error
    print("\nTest 3 - Error (n=0):")
    problem6_pattern_printing(0)

    print("\n" + "=" * 70)
    print("All tests completed.")
    print("=" * 70 + "\n")


# Ejecutar pruebas sólo si este archivo se ejecuta como script principal
if __name__ == "__main__":
    run_all_tests()


# Conclusiones 

# For loops are ideal when the number of iterations is known in advance,
# such as summing a range or printing a multiplication table. While loops
# are natural when repetition depends on a condition (sentinel, user input).
# Counters and accumulators help track counts and totals clearly inside loops.
# The main risk with while loops is creating infinite loops; always ensure
# the loop control variable is updated and conditions are reachable.
# Nested loops are useful for patterns and matrices, but they increase time
# complexity and should be used judiciously.

# Referencias  

# References:
# 1) Python documentation - The for statement and The while statement
#    https://docs.python.org/3/tutorial/controlflow.html#for-statements
# 2) Python Tutorial — Data Structures and Control Flow (official tutorial)
#    https://docs.python.org/3/tutorial/
# 3) Real Python - articles on loops and iteration (realpython.com)
# 4) "Automate the Boring Stuff with Python" - chapters on flow control
# 5) Lecture notes and classroom resources on loops, sentinels, counters and accumulators


# URL

# https://github.com/Cesar2530405/metodolog-as_de_la_programacion_Prueba.git
# git@github.com:Cesar2530405/metodolog-as_de_la_programacion_Prueba.git